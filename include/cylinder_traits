#ifndef _TRIPLET_MATCH_CYLINDER_TRAITS_
#define _TRIPLET_MATCH_CYLINDER_TRAITS_

#include "common"
#include "discretize"
#include "pointcloud"

namespace triplet_match {

template <typename Point>
struct cylinder_traits {
    typedef pointcloud<Point> cloud_t;
    struct state_t {
        float radius;
        vec3f_t origin;
        mat4f_t g2l;
        mat4f_t l2g;
        bbox3_t uvw_bounds;
    };
    typedef std::shared_ptr<state_t> handle_t;
    typedef std::shared_ptr<const state_t> const_handle_t;

    static constexpr int feature_dimension = 2;
    static constexpr int sample_count = 2;

    typedef std::array<Point, sample_count> samples_t;
    typedef Eigen::Matrix<float, feature_dimension, 1> feature_t;
    typedef Eigen::Matrix<uint32_t, feature_dimension, 1> discrete_feature_t;
    typedef Eigen::AlignedBox<float, feature_dimension> feature_bounds_t;

    static handle_t
    init_from_model(typename cloud_t::ConstPtr cloud,
                    const subset_t& subset = subset_t());

    static handle_t init_from_samples(const samples_t& samples);

    //static mat4f_t
    //alignment(const_handle_t handle_i, const_handle_t handle_j,
    //          const samples_t& samples_i, const samples_t& samples_j, bool debug = false);

    static vec3f_t project(const_handle_t handle, const vec3f_t& xyz);

    static vec3f_t unproject(const_handle_t handle, const vec3f_t& uvw);

    static vec3f_t tangent(const_handle_t handle, const Point& pnt);

    static float intrinsic_distance(const_handle_t handle, const vec3f_t& p0,
                                    const vec3f_t& p1);

    static feature_t
    feature(const_handle_t handle, const Point& pnt_0, const Point& pnt_1);

    static discrete_feature_t
    discretize_feature(const_handle_t handle, const feature_t& f,
                       const feature_bounds_t& bounds,
                       const discretization_params& params);

    static bool
    valid(const_handle_t handle, const feature_t& f, const feature_bounds_t& bounds, float min_angle, float max_angle, float min_rel_dist, float max_rel_dist);

    //static std::string opencl_source();

    // static vec3f_t unproject(std::shared_ptr<const state_t>& handle, const
    // vec3f_t& uvw) {
    //}
};

}  // namespace triplet_match

#ifndef TRIPLET_MATCH_PRECOMPILE_HEADERS
#include "impl/cylinder_traits.hpp"
#endif  // TRIPLET_MATCH_PRECOMPILE_HEADERS

#endif /* _TRIPLET_MATCH_CYLINDER_TRAITS_ */
       // vim: syntax=cpp:
