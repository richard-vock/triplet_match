#ifndef _TRIPLET_MATCH_STRATIFIED_SEARCH_
#define _TRIPLET_MATCH_STRATIFIED_SEARCH_

#include <unordered_map>

#include "common"
#include "model"
#include "octree"

#include <voxel_score/score_functor>

namespace triplet_match {

template <typename Point>
class stratified_search {
public:
    typedef std::unique_ptr<stratified_search<Point>> uptr_t;
    typedef std::shared_ptr<stratified_search<Point>> sptr_t;
    typedef std::weak_ptr<stratified_search<Point>> wptr_t;
    typedef std::shared_ptr<const stratified_search<Point>> const_sptr_t;
    typedef std::weak_ptr<const stratified_search<Point>> const_wptr_t;

    typedef pcl::PointCloud<Point> cloud_t;
    typedef octree<Point> octree_t;

public:
    stratified_search(typename cloud_t::ConstPtr cloud,
                      const sample_parameters& sample_params,
                      float model_diameter, float octree_diameter_factor);

    virtual ~stratified_search();

    void set_model(typename model<Point>::sptr_t m);

    void reset();

    template <typename PointModel>
    std::pair<std::vector<mat4f_t>, std::vector<subset_t>>
    find_all(model<PointModel>& m, float model_match_factor,
             float score_distance_factor, float early_out_factor,
             uint32_t max_icp_iterations);

    typename octree_t::sptr_t get_octree();

    typename octree_t::const_sptr_t get_octree() const;

    voxel_score::score_functor<Point, Point>& get_score_functor();

protected:
    struct impl;
    std::unique_ptr<impl> impl_;
};

}  // namespace triplet_match

#ifndef TRIPLET_MATCH_PRECOMPILE_HEADERS
#include "impl/stratified_search.hpp"
#endif  // TRIPLET_MATCH_PRECOMPILE_HEADERS

#endif /* _TRIPLET_MATCH_STRATIFIED_SEARCH_ */
       // vim: syntax=cpp:
