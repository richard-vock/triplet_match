#ifndef _TRIPLET_MATCH_CYLINDER_
#define _TRIPLET_MATCH_CYLINDER_

#include <pcl/sample_consensus/sac_model_cylinder.h>
#include <pcl/sample_consensus/msac.h>

#include "common"

namespace triplet_match {

template <typename Point>
class cylinder {
public:
    typedef std::unique_ptr<cylinder<Point>> uptr_t;
    typedef std::shared_ptr<cylinder<Point>> sptr_t;
    typedef std::weak_ptr<cylinder<Point>> wptr_t;
    typedef std::shared_ptr<const cylinder<Point>> const_sptr_t;
    typedef std::weak_ptr<const cylinder<Point>> const_wptr_t;

    typedef pcl::PointCloud<Point> cloud_t;
    typedef pcl::SampleConsensusModelCylinder<Point, Point> pcl_model_t;

public:
    cylinder(float threshold);

    virtual ~cylinder();

    void fit(typename cloud_t::ConstPtr cloud, const subset_t& subset = subset_t());

    void fit(const Point& sample1, const Point& sample2);

    mat4f_t transform_to(const cylinder<Point>& other, const vec3f_t& ref1, const vec3f_t& ref2) const;

    vec3f_t project(const vec3f_t& pos) const;

    vec3f_t unproject(const vec2f_t& uv) const;

    vec3f_t unproject(const vec3f_t& pos) const;

    vec2f_t intrinsic_difference(const vec3f_t& pos0, const vec3f_t& pos1, bool debug = false) const;

    vec3f_t& origin();

    const vec3f_t& origin() const;

    vec3f_t& axis();

    const vec3f_t& axis() const;

    float& radius();

    const float& radius() const;

    mat4f_t& projection_matrix();

    const mat4f_t& projection_matrix() const;

    static std::string opencl_path();

protected:
    float threshold_;
    vec3f_t origin_;
    vec3f_t axis_;
    float radius_;
    mat4f_t proj_;
    mat4f_t inv_;
};

}  // namespace triplet_match

#include "cylinder.ipp"

#endif /* _TRIPLET_MATCH_CYLINDER_ */

// vim: syntax=cpp
